import type { Response, Request } from 'express';

import { generateAccessToken, generateRefreshToken } from './user.controller';
import { Errors } from '../environments/errors.environment';
import { HttpStatusCodes, HttpStatusCodesDescriptions } from '../environments/httpStatusCodes.environment';
import Ticket from '../models/ticket.model';
import type { IRequest } from '../types/global.type';
import type { ITicket } from '../types/ticket.type';
import { ApiResponse } from '../utils/apiResponse';
import { sendEmail } from '../utils/email';
import { getRandomInt } from '../utils/functions';

export const getTicket = async (req: Request, res: Response): Promise<ApiResponse> => {
  try {
    const { ticketId } = req.params;

    if (!ticketId) {
      return new ApiResponse(res, Errors.BAD_REQUEST_RESPONSE);
    }

    const ticket: ITicket | null = await Ticket.findOne({ ticketId }).select(['-__v', '-_id']).populate('user');
    if (!ticket) {
      return new ApiResponse(res, Errors.NOT_FOUND_RESPONSE);
    }

    return new ApiResponse(res, {
      name: 'Success',
      httpStatusCode: HttpStatusCodes.SUCCESS,
      description: HttpStatusCodesDescriptions.SUCCESS,
      data: ticket,
    });
  } catch (error) {
    return new ApiResponse(res, Errors.INTERNAL_SERVER_RESPONSE, error);
  }
};

export const getTickets = async (_: Request, res: Response): Promise<ApiResponse> => {
  try {
    const tickets: ITicket[] = await Ticket.find().select(['-__v', '-_id']).populate('user');
    return new ApiResponse(res, {
      name: 'Success',
      httpStatusCode: HttpStatusCodes.SUCCESS,
      description: HttpStatusCodesDescriptions.SUCCESS,
      data: tickets,
    });
  } catch (error) {
    return new ApiResponse(res, Errors.INTERNAL_SERVER_RESPONSE, error);
  }
};

export const checkTicket = async (req: Request, res: Response): Promise<ApiResponse> => {
  try {
    const { ticketId } = req.params;

    if (!ticketId) {
      return new ApiResponse(res, Errors.BAD_REQUEST_RESPONSE);
    }

    const ticket: ITicket | null = await Ticket.findOne({ ticketId }).select(['-__v']).populate('user');
    if (!ticket) {
      return new ApiResponse(res, Errors.NOT_FOUND_RESPONSE);
    }

    let secretCode = getRandomInt();
    const secretCodeExist = await Ticket.exists({ code: secretCode });

    if (secretCodeExist) {
      while (Ticket.exists({ code: secretCode })) {
        secretCode = getRandomInt();
      }
    }
    await Ticket.findByIdAndUpdate(ticket.id, { $set: { code: secretCode } });

    sendEmail(ticket.user.email, 'Ticket checked', `Code: ${secretCode}`);

    return new ApiResponse(res, {
      name: 'Success',
      httpStatusCode: HttpStatusCodes.SUCCESS,
      description: HttpStatusCodesDescriptions.SUCCESS,
    });
  } catch (error) {
    return new ApiResponse(res, Errors.INTERNAL_SERVER_RESPONSE, error);
  }
};

export const addTicket = async (req: IRequest, res: Response): Promise<ApiResponse> => {
  try {
    const { validityPeriod } = req.body;

    if (!validityPeriod || (!validityPeriod[0] && !validityPeriod[1])) {
      return new ApiResponse(res, Errors.BAD_REQUEST_RESPONSE);
    }

    const ticket: ITicket = new Ticket({
      user: req.user?.id,
      validityPeriod,
    });
    await ticket.save();

    // Return accessToken if user has been generated by us to let him
    // use our API and avoid spamming
    return new ApiResponse(res, {
      name: 'Success',
      httpStatusCode: HttpStatusCodes.CREATED,
      description: HttpStatusCodesDescriptions.CREATED,
      data: {
        ticketId: ticket.ticketId,
        accessToken: req.headers.authorization?.split(' ')[1],
      },
    });
  } catch (error) {
    return new ApiResponse(res, Errors.INTERNAL_SERVER_RESPONSE, error);
  }
};

export const deleteTicket = async (req: Request, res: Response): Promise<ApiResponse> => {
  try {
    const { ticketId } = req.params;

    if (!ticketId) {
      return new ApiResponse(res, Errors.BAD_REQUEST_RESPONSE);
    }

    const ticket = await Ticket.findOneAndDelete({ ticketId }).select(['-__v', '-_id']);
    if (!ticket) {
      return new ApiResponse(res, Errors.NOT_FOUND_RESPONSE);
    }

    return new ApiResponse(res, {
      name: 'Success',
      httpStatusCode: HttpStatusCodes.SUCCESS,
      description: HttpStatusCodesDescriptions.SUCCESS,
      data: ticket,
    });
  } catch (error) {
    return new ApiResponse(res, Errors.INTERNAL_SERVER_RESPONSE, error);
  }
};

export const validateTicket = async (req: IRequest, res: Response): Promise<ApiResponse> => {
  try {
    const { ticketNb } = req.query;
    const { code } = req.body;

    const ticket = await Ticket.findOne({ ticketNb, code }).populate('user');
    if (!ticket) {
      return new ApiResponse(res, {
        name: 'Success',
        httpStatusCode: HttpStatusCodes.SUCCESS,
        description: HttpStatusCodesDescriptions.BAD_REQUEST,
      });
    }

    const baseData = {
      id: ticket.user.id,
      email: ticket.user.email,
      role: ticket.user.role,
    };

    const otherData = {
      firstname: ticket.user.firstname,
      lastname: ticket.user.lastname,
      cv: ticket.user.cv,
    };
    const base64 = Buffer.from(JSON.stringify({ ...baseData, ...otherData })).toString('base64');

    return new ApiResponse(res, {
      name: 'Success',
      httpStatusCode: HttpStatusCodes.SUCCESS,
      description: HttpStatusCodesDescriptions.SUCCESS,
      data: {
        accessToken: generateAccessToken(baseData),
        refreshToken: generateRefreshToken(baseData),
        user: base64,
      },
    });
  } catch (error) {
    return new ApiResponse(res, Errors.INTERNAL_SERVER_RESPONSE, error);
  }
};
